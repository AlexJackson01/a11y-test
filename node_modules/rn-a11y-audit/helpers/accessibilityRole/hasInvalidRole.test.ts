import * as t from "@babel/types";
import { hasInvalidRole } from "./hasInvalidRole";
import { roleCode } from "../../constants";

describe("hasInvalidRole", () => {
  // minimal NodePath-like object with line number
  const makePath = (line = 10) =>
    ({ node: { loc: { start: { line } } } } as any);

  it("returns null when accessibilityRole attribute is missing", () => {
    const attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[] = [];
    const result = hasInvalidRole("View", attributes, makePath());
    expect(result).toBeNull();
  });

  it("returns null when role is a valid string literal", () => {
    const attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[] = [
      t.jsxAttribute(t.jsxIdentifier("accessibilityRole"), t.stringLiteral("button")),
    ];
    const result = hasInvalidRole("Pressable", attributes, makePath(12));
    expect(result).toBeNull();
  });

  it("returns a violation when role is an invalid string literal", () => {
    const attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[] = [
      t.jsxAttribute(t.jsxIdentifier("accessibilityRole"), t.stringLiteral("not-a-role")),
    ];
    const path = makePath(15);
    const result = hasInvalidRole("View", attributes, path);

    expect(result).not.toBeNull();
    expect(result?.tag).toBe("View");
    expect(result?.line).toBe(15);
    expect(result?.existingText).toBe("not-a-role");
    expect(result?.text).toContain(roleCode);
    expect(result?.text).toContain("'not-a-role' is invalid");
  });

  it("returns null when role is a valid string inside a JSXExpressionContainer", () => {
    const expr = t.jsxExpressionContainer(t.stringLiteral("image"));
    const attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[] = [
      t.jsxAttribute(t.jsxIdentifier("accessibilityRole"), expr),
    ];
    const result = hasInvalidRole("Image", attributes, makePath(20));
    expect(result).toBeNull();
  });

  it("returns a violation when role is an invalid string inside a JSXExpressionContainer", () => {
    const expr = t.jsxExpressionContainer(t.stringLiteral("nope"));
    const attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[] = [
      t.jsxAttribute(t.jsxIdentifier("accessibilityRole"), expr),
    ];
    const path = makePath(22);
    const result = hasInvalidRole("Text", attributes, path);

    expect(result).not.toBeNull();
    expect(result?.tag).toBe("Text");
    expect(result?.line).toBe(22);
    expect(result?.existingText).toBe("nope");
    expect(result?.text).toContain(roleCode);
    expect(result?.text).toContain("'nope' is invalid");
  });

  it("returns a violation with existingText null when role is a non-string expression", () => {
    // e.g. accessibilityRole={someVar}
    const expr = t.jsxExpressionContainer(t.identifier("someVar"));
    const attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[] = [
      t.jsxAttribute(t.jsxIdentifier("accessibilityRole"), expr),
    ];
    const path = makePath(30);
    const result = hasInvalidRole("Custom", attributes, path);

    expect(result).not.toBeNull();
    expect(result?.tag).toBe("Custom");
    expect(result?.line).toBe(30);
    expect(result?.existingText).toBeNull();
    expect(result?.text).toContain(roleCode);
    expect(result?.text).toContain("'null' is invalid");
  });
});
