import * as t from "@babel/types";
import { LabelTargets } from "../../types";
import { NodePath } from "@babel/traverse";
import { roleCode, ALL_ROLES } from "../../constants";

function isValidRole(role: string | null | undefined): boolean {
  if (!role) return false;
  // Support either Set<string> or string[]
  const anyRoles = ALL_ROLES as any;
  if (typeof anyRoles.has === "function") {
    return anyRoles.has(role);
  }
  if (Array.isArray(anyRoles)) {
    return anyRoles.includes(role);
  }
  // Fallback (be conservative)
  return false;
}

export const hasInvalidRole = (
  tag: string,
  attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[],
  path: NodePath<t.JSXElement>
): LabelTargets | null => {
  const roleAttr = attributes.find(
    (attr): attr is t.JSXAttribute =>
      t.isJSXAttribute(attr) &&
      t.isJSXIdentifier(attr.name) &&
      attr.name.name === "accessibilityRole"
  );

  if (!roleAttr || !roleAttr.value) {
    return null;
  }

  let roleValue: string | null = null;

  if (t.isStringLiteral(roleAttr.value)) {
    roleValue = roleAttr.value.value;
  } else if (
    t.isJSXExpressionContainer(roleAttr.value) &&
    t.isStringLiteral(roleAttr.value.expression)
  ) {
    roleValue = roleAttr.value.expression.value;
  } else {
    // Non-string expressions (e.g., identifier, member expression)
    roleValue = null;
  }

  if (isValidRole(roleValue)) {
    return null;
  }

  return {
    tag,
    path,
    line: path.node.loc?.start.line || 0,
    text: `${roleCode} - '${roleValue}' is invalid`,
    existingText: roleValue,
  };
};
