// helpers/accessibilityRole/auditAccessibilityRoles.test.ts
import * as t from "@babel/types";
import type { NodePath } from "@babel/traverse";
import { auditAccessibilityRoles } from "./auditAccessibilityRoles";
import { roleCode } from "../../constants";

// ---- Mocks for collaborators ----
jest.mock("./hasInvalidRole", () => ({
  hasInvalidRole: jest.fn(),
}));
jest.mock("./suggestRole", () => ({
  suggestRole: jest.fn(),
  suggestRoleFromFilename: jest.fn(),
  isTopLevelJSX: jest.fn(),
}));

import { hasInvalidRole } from "./hasInvalidRole";
import { suggestRole, suggestRoleFromFilename, isTopLevelJSX } from "./suggestRole";

// ---- Test helpers ----
const makePath = (line = 5) =>
  ({
    node: { loc: { start: { line } } },
  } as unknown as NodePath<t.JSXElement>);

const makeAttrs = (pairs: Array<[string, t.JSXAttribute["value"] | string]>) =>
  pairs.map(([name, value]) =>
    t.jsxAttribute(
      t.jsxIdentifier(name),
      typeof value === "string" ? t.stringLiteral(value) : (value as any)
    )
  ) as (t.JSXAttribute | t.JSXSpreadAttribute)[];

describe("auditAccessibilityRoles", () => {
  const filePath = "/src/components/Thing.tsx";

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("shouldFix = true (auto-fix pass)", () => {
    it("seeds first top-level element with filename-suggested role when none present", () => {
      (suggestRoleFromFilename as jest.Mock).mockReturnValue("checkbox");
      (isTopLevelJSX as jest.Mock).mockReturnValue(true);

      const roleTargets: any[] = [];
      const report: any[] = [];
      const options = { filePath, perFile: { seededFirstLayer: false } };

      auditAccessibilityRoles(
        "View",
        /* attributes: no role */ [],
        makePath(12),
        filePath,
        roleTargets,
        true,
        report,
        /* prComments */ undefined,
        options
      );

      expect(roleTargets).toEqual([
        {
          tag: "View",
          path: expect.any(Object),
          line: 12,
          text: "checkbox",
        },
      ]);
      expect(report).toEqual([
        {
          type: "accessibilityRole",
          tag: "View",
          text: "checkbox",
          location: filePath,
        },
      ]);
      // seeded flag updated
      expect(options.perFile?.seededFirstLayer).toBe(true);
      // No calls to suggestRole in this path
      expect(suggestRole).not.toHaveBeenCalled();
    });

    it("does not seed if already seededFirstLayer is true", () => {
      (suggestRoleFromFilename as jest.Mock).mockReturnValue("checkbox");
      (isTopLevelJSX as jest.Mock).mockReturnValue(true);

      const roleTargets: any[] = [];
      const report: any[] = [];
      const options = { filePath, perFile: { seededFirstLayer: true } };

      auditAccessibilityRoles(
        "View",
        [],
        makePath(10),
        filePath,
        roleTargets,
        true,
        report,
        undefined,
        options
      );

      expect(roleTargets).toHaveLength(0);
      expect(report).toHaveLength(0);
    });

    it("does not seed if element is not top-level", () => {
      (suggestRoleFromFilename as jest.Mock).mockReturnValue("checkbox");
      (isTopLevelJSX as jest.Mock).mockReturnValue(false);

      const roleTargets: any[] = [];
      const report: any[] = [];
      const options = { filePath, perFile: { seededFirstLayer: false } };

      auditAccessibilityRoles(
        "View",
        [],
        makePath(10),
        filePath,
        roleTargets,
        true,
        report,
        undefined,
        options
      );

      expect(roleTargets).toHaveLength(0);
      expect(report).toHaveLength(0);
    });

    it("suggests role via suggestRole when element has no role and filename seeding didnâ€™t apply", () => {
      (suggestRoleFromFilename as jest.Mock).mockReturnValue(null);
      (isTopLevelJSX as jest.Mock).mockReturnValue(true);
      (suggestRole as jest.Mock).mockReturnValue("button");

      const roleTargets: any[] = [];
      const report: any[] = [];

      auditAccessibilityRoles(
        "TouchableOpacity",
        /* no role */ [],
        makePath(7),
        filePath,
        roleTargets,
        true,
        report
      );

      expect(suggestRole).toHaveBeenCalledWith(
        "TouchableOpacity",
        expect.any(Array)
      );
      expect(roleTargets).toEqual([
        {
          tag: "TouchableOpacity",
          path: expect.any(Object),
          line: 7,
          text: "button",
        },
      ]);
      expect(report).toEqual([
        {
          type: "accessibilityRole",
          tag: "TouchableOpacity",
          text: "button",
          location: filePath,
        },
      ]);
    });

    it("does nothing if element already has accessibilityRole", () => {
      const attrs = makeAttrs([["accessibilityRole", "image"]]);

      const roleTargets: any[] = [];
      const report: any[] = [];

      auditAccessibilityRoles(
        "Image",
        attrs,
        makePath(3),
        filePath,
        roleTargets,
        true,
        report
      );

      expect(roleTargets).toHaveLength(0);
      expect(report).toHaveLength(0);
      expect(suggestRole).not.toHaveBeenCalled();
    });

    it("does nothing if suggestRole returns null", () => {
      (suggestRoleFromFilename as jest.Mock).mockReturnValue(null);
      (isTopLevelJSX as jest.Mock).mockReturnValue(true);
      (suggestRole as jest.Mock).mockReturnValue(null);

      const roleTargets: any[] = [];
      const report: any[] = [];

      auditAccessibilityRoles(
        "CustomThing",
        /* no role */ [],
        makePath(19),
        filePath,
        roleTargets,
        true,
        report
      );

      expect(roleTargets).toHaveLength(0);
      expect(report).toHaveLength(0);
    });
  });

  describe("shouldFix = false (PR-comment pass)", () => {
    it("pushes PR comment with suggestion when role is invalid and suggestRole returns a role", () => {
      (hasInvalidRole as jest.Mock).mockReturnValue({
        tag: "View",
        path: makePath(11),
        line: 11,
        text: `${roleCode} - 'nope' is invalid`,
        existingText: "nope",
      });
      (suggestRole as jest.Mock).mockReturnValue("header");

      const prComments: any[] = [];

      auditAccessibilityRoles(
        "View",
        makeAttrs([["accessibilityRole", "nope"]]),
        makePath(11),
        filePath,
        /* roleTargets */ [],
        /* shouldFix */ false,
        /* report */ [],
        prComments
      );

      expect(prComments).toEqual([
        {
          type: "accessibilityRole",
          tag: "View",
          line: 11,
          text: expect.stringContaining(`${roleCode}: <View> on line 11 has an invalid accessibilityRole "nope".`),
          location: filePath,
        },
      ]);
      expect(prComments[0].text).toContain('Suggested: "header".');
    });

    it("pushes PR comment without suggestion when suggestRole returns null", () => {
      (hasInvalidRole as jest.Mock).mockReturnValue({
        tag: "Text",
        path: makePath(21),
        line: 21,
        text: `${roleCode} - 'wrong' is invalid`,
        existingText: "wrong",
      });
      (suggestRole as jest.Mock).mockReturnValue(null);

      const prComments: any[] = [];

      auditAccessibilityRoles(
        "Text",
        makeAttrs([["accessibilityRole", "wrong"]]),
        makePath(21),
        filePath,
        [],
        false,
        [],
        prComments
      );

      expect(prComments).toHaveLength(1);
      expect(prComments[0].text).toContain(
        `${roleCode}: <Text> on line 21 has an invalid accessibilityRole "wrong".`
      );
      expect(prComments[0].text).not.toContain("Suggested:");
    });

    it("does nothing when hasInvalidRole returns null", () => {
      (hasInvalidRole as jest.Mock).mockReturnValue(null);

      const prComments: any[] = [];

      auditAccessibilityRoles(
        "Image",
        makeAttrs([["accessibilityRole", "image"]]),
        makePath(8),
        filePath,
        [],
        false,
        [],
        prComments
      );

      expect(prComments).toHaveLength(0);
    });
  });
});
