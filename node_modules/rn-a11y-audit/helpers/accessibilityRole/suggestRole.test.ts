import * as t from "@babel/types";
import { suggestRoleFromTagName, suggestRoleFromFilename, suggestRole, isTopLevelJSX } from "./suggestRole";
import { roleMap } from "../../constants";

describe("suggestRoleFromTagName", () => {
  it("maps touchables to button", () => {
    expect(suggestRoleFromTagName("TouchableOpacity")).toBe("button");
    expect(suggestRoleFromTagName("Pressable")).toBe("button");
  });

  it("maps natives/common directly", () => {
    expect(suggestRoleFromTagName("Image")).toBe("image");
    expect(suggestRoleFromTagName("Switch")).toBe("switch");
    expect(suggestRoleFromTagName("ActivityIndicator")).toBe("progressbar");
    expect(suggestRoleFromTagName("FlatList")).toBe("list");
  });

  it("maps custom-ish names", () => {
    expect(suggestRoleFromTagName("Checkbox")).toBe("checkbox");
    expect(suggestRoleFromTagName("Dropdown")).toBe("combobox");
    expect(suggestRoleFromTagName("Carousel")).toBe("adjustable");
    expect(suggestRoleFromTagName("Header")).toBe("header");
    expect(suggestRoleFromTagName("Toolbar")).toBe("toolbar");
    expect(suggestRoleFromTagName("Tab")).toBe("tab");
    expect(suggestRoleFromTagName("Menu")).toBe("menu");
    expect(suggestRoleFromTagName("Toggle")).toBe("togglebutton");
    expect(suggestRoleFromTagName("Grid")).toBe("grid");
  });
});

describe("suggestRoleFromFilename", () => {
  it("infers roles from filename keywords", () => {
    expect(suggestRoleFromFilename("/x/checkbox.tsx")).toBe("checkbox");
    expect(suggestRoleFromFilename("/x/dropdown.tsx")).toBe("combobox");
    expect(suggestRoleFromFilename("/x/progress.tsx")).toBe("progressbar");
    expect(suggestRoleFromFilename("/x/header.tsx")).toBe("header");
    expect(suggestRoleFromFilename("/x/toolbar.tsx")).toBe("toolbar");
    expect(suggestRoleFromFilename("/x/tab.tsx")).toBe("tab");
    expect(suggestRoleFromFilename("/x/menu.tsx")).toBe("menu");
    expect(suggestRoleFromFilename("/x/toggle.tsx")).toBe("togglebutton");
    expect(suggestRoleFromFilename("/x/grid.tsx")).toBe("grid");
    expect(suggestRoleFromFilename("/x/list.tsx")).toBe("list");
    expect(suggestRoleFromFilename("/x/switch.tsx")).toBe("switch");
    expect(suggestRoleFromFilename("/x/image.tsx")).toBe("image");
    expect(suggestRoleFromFilename("/x/alert.tsx")).toBe("alert");
  });
});

describe("suggestRole (style header hint)", () => {
  it("returns 'header' when style indicates header-ish key", () => {
    const attrs: any[] = [
      // style={styles.header}
      t.jsxAttribute(
        t.jsxIdentifier("style"),
        t.jsxExpressionContainer(
          t.memberExpression(t.identifier("styles"), t.identifier("header"))
        )
      ),
    ];
    expect(suggestRole("View", attrs)).toBe("header");
  });

  it("returns null for non-header style", () => {
    const attrs: any[] = [
      t.jsxAttribute(
        t.jsxIdentifier("style"),
        t.jsxExpressionContainer(
          t.memberExpression(t.identifier("styles"), t.identifier("container"))
        )
      ),
    ];
    expect(suggestRole("View", attrs)).toBeNull();
  });
});

describe("isTopLevelJSX", () => {
  it("is true if no parent JSXElement exists", () => {
    // minimal NodePath mock: no parent finder
    const path: any = { findParent: jest.fn(() => null) };
    expect(isTopLevelJSX(path)).toBe(true);
    expect(path.findParent).toHaveBeenCalled();
  });
});

describe("coverage: every role in roleMap is reachable", () => {
  it("each unique role can be produced by tag or filename (or header style)", () => {
    const uniqueRoles = Array.from(new Set(Object.values(roleMap)));

    const tagKeys = Object.keys(roleMap);

    for (const role of uniqueRoles) {
      const foundViaTag = tagKeys.some((k) => roleMap[k] === role);
      const foundViaFilename =
        suggestRoleFromFilename(`/tmp/${role}.tsx`) === role ||
        suggestRoleFromFilename(`/tmp/my-${role}.tsx`) === role;

      // header can also be produced by style hint; we wonâ€™t instantiate a full AST here again
      const reachable = foundViaTag || foundViaFilename || role === "header";
      expect(reachable).toBe(true);
    }
  });
});
