import * as t from "@babel/types";
import type { NodePath } from "@babel/traverse";
import { stateCode } from "../../constants";

jest.mock("./suggestState", () => ({
  inferFromFilename: jest.fn(),
  inferFromTag: jest.fn(),
  hasAriaState: jest.fn(),
  NON_INTERACTIVE: new Set(["Text"]),
}));

import { inferFromFilename, inferFromTag, hasAriaState } from "./suggestState";
import { auditAccessibilityStates } from "./auditAccessibilityStates";

type Attr = t.JSXAttribute | t.JSXSpreadAttribute;

const makePath = (
  line = 10,
  { topLevel = true }: { topLevel?: boolean } = {}
) =>
  ({
    node: { loc: { start: { line } } },
    // isTopLevelJSX() checks no parent JSX => we return null
    findParent: jest.fn((fn: any) =>
      topLevel ? null : ({ isJSXElement: () => true } as any)
    ),
  }) as unknown as NodePath<t.JSXElement>;

const filePath = "src/Checkbox.tsx";

describe("auditAccessibilityStates", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("skips non-interactive tags (Text)", () => {
    const prComments: any[] = [];
    (inferFromFilename as jest.Mock).mockReturnValue(null);
    (inferFromTag as jest.Mock).mockReturnValue(null);
    (hasAriaState as jest.Mock).mockReturnValue(false);

    auditAccessibilityStates(
      "Text",
      [],
      makePath(5, { topLevel: true }),
      filePath,
      prComments,
      { filePath, perFile: { seededFirstLayer: false } }
    );

    expect(prComments).toHaveLength(0);
  });

  it("seeds once from filename on the first top-level element", () => {
    const prComments: any[] = [];
    const options = { filePath, perFile: { seededFirstLayer: false } };

    // filename => 'checked' (e.g., Checkbox.tsx)
    (inferFromFilename as jest.Mock).mockReturnValue("checked");
    (inferFromTag as jest.Mock).mockReturnValue(null);
    (hasAriaState as jest.Mock).mockReturnValue(false);

    auditAccessibilityStates(
      "View",
      [],
      makePath(7, { topLevel: true }),
      filePath,
      prComments,
      options
    );

    expect(prComments).toHaveLength(1);
    expect(prComments[0]).toEqual(
      expect.objectContaining({
        type: "accessibilityState",
        tag: "View",
        line: 7,
        location: filePath,
      })
    );
    expect(options.perFile?.seededFirstLayer).toBe(true);
    expect(prComments[0].text).toContain(stateCode);
    expect(prComments[0].text).toContain(
      "accessibilityState={{ checked: ... }}"
    );
  });

  it("suggests from tag mapping when not top-level (no filename influence)", () => {
    const prComments: any[] = [];
    const options = { filePath, perFile: { seededFirstLayer: true } };

    (inferFromFilename as jest.Mock).mockReturnValue(null);
    (inferFromTag as jest.Mock).mockReturnValue("checked");
    (hasAriaState as jest.Mock).mockReturnValue(false);

    auditAccessibilityStates(
      "Switch",
      [],
      makePath(20, { topLevel: false }),
      filePath,
      prComments,
      options
    );

    expect(prComments).toHaveLength(1);
    expect(prComments[0]).toEqual(
      expect.objectContaining({
        type: "accessibilityState",
        tag: "Switch",
        line: 20,
        location: filePath,
      })
    );
    expect(prComments[0].text).toContain(
      "accessibilityState={{ checked: ... }}"
    );
  });

  it("does nothing if ARIA equivalent already exists (e.g., aria-checked)", () => {
    const prComments: any[] = [];
    const options = { filePath, perFile: { seededFirstLayer: true } };

    (inferFromFilename as jest.Mock).mockReturnValue(null);
    (inferFromTag as jest.Mock).mockReturnValue("checked");
    (hasAriaState as jest.Mock).mockReturnValue(true);

    auditAccessibilityStates(
      "Switch",
      [],
      makePath(30, { topLevel: false }),
      filePath,
      prComments,
      options
    );

    expect(prComments).toHaveLength(0);
  });

  it("does nothing if accessibilityState already present", () => {
    const prComments: any[] = [];
    const options = { filePath, perFile: { seededFirstLayer: true } };

    (inferFromFilename as jest.Mock).mockReturnValue(null);
    (inferFromTag as jest.Mock).mockReturnValue("checked");
    (hasAriaState as jest.Mock).mockReturnValue(false);

    // accessibilityState={{ checked: true }}
    const attrs: Attr[] = [
      t.jsxAttribute(
        t.jsxIdentifier("accessibilityState"),
        t.jsxExpressionContainer(
          t.objectExpression([
            t.objectProperty(t.identifier("checked"), t.booleanLiteral(true)),
          ])
        )
      ),
    ];

    auditAccessibilityStates(
      "Switch",
      attrs,
      makePath(40, { topLevel: false }),
      filePath,
      prComments,
      options
    );

    expect(prComments).toHaveLength(0);
  });

  it("posts a missing state suggestion with correct line and message", () => {
    const prComments: any[] = [];
    const options = { filePath, perFile: { seededFirstLayer: true } };

    (inferFromFilename as jest.Mock).mockReturnValue(null);
    (inferFromTag as jest.Mock).mockReturnValue("expanded");
    (hasAriaState as jest.Mock).mockReturnValue(false);

    auditAccessibilityStates(
      "Accordion",
      [],
      makePath(55, { topLevel: false }),
      filePath,
      prComments,
      options
    );

    expect(prComments).toHaveLength(1);
    expect(prComments[0].line).toBe(55);
    expect(prComments[0].text).toContain(stateCode);
    expect(prComments[0].text).toContain(
      "accessibilityState={{ expanded: ... }}"
    );
  });
});
