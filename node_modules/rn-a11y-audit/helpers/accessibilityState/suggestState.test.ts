import path from "path";
import { inferFromTag, inferFromFilename, hasAriaState, NON_INTERACTIVE } from "./suggestState";
import { stateMap } from "../../constants";

// Mock hasProp so we can verify arguments & control return values
jest.mock("../hasProp", () => ({
  hasProp: jest.fn(),
}));

import { hasProp } from "../hasProp";

describe("suggestState helpers", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("inferFromTag", () => {
    it("returns mapped state for known tags", () => {
      // sanity: ensure a few keys exist in your stateMap
      expect(stateMap.Switch).toBe("checked");
      expect(stateMap.Checkbox).toBe("checked");
      expect(inferFromTag("Switch")).toBe("checked");
      expect(inferFromTag("Checkbox")).toBe("checked");
    });

    it("returns null for unknown tags", () => {
      expect(inferFromTag("TotallyCustom")).toBeNull();
    });
  });

  describe("inferFromFilename", () => {
    it("returns state when filename includes a mapped component name (case-insensitive)", () => {
      const p1 = path.join("src", "components", "MyCheckbox.tsx");
      const p2 = path.join("screens", "UserSwitchScreen.jsx");
      const p3 = path.join("widgets", "DropdownMenu.tsx");

      // According to your stateMap:
      //  Checkbox -> checked
      //  Switch -> checked
      //  Dropdown -> expanded  (per your stateMap)
      expect(inferFromFilename(p1)).toBe("checked");
      expect(inferFromFilename(p2)).toBe("checked");
      expect(inferFromFilename(p3)).toBe("expanded");
    });

    it("returns null when no mapped component name is present", () => {
      const p = path.join("src", "Foo", "SomethingElse.tsx");
      expect(inferFromFilename(p)).toBeNull();
    });

    it("returns null for undefined path", () => {
      expect(inferFromFilename(undefined)).toBeNull();
    });
  });

  describe("hasAriaState", () => {
    const attrs: any[] = [{ some: "attr" }];

    it("checks aria-checked when key is 'checked'", () => {
      (hasProp as jest.Mock).mockReturnValue(true);
      const result = hasAriaState(attrs, "checked");
      expect(hasProp).toHaveBeenCalledWith("aria-checked", attrs);
      expect(result).toBe(true);
    });

    it("checks aria-expanded when key is 'expanded'", () => {
      (hasProp as jest.Mock).mockReturnValue(false);
      const result = hasAriaState(attrs, "expanded");
      expect(hasProp).toHaveBeenCalledWith("aria-expanded", attrs);
      expect(result).toBe(false);
    });

    it("checks aria-selected when key is 'selected'", () => {
      (hasProp as jest.Mock).mockReturnValue(true);
      const result = hasAriaState(attrs, "selected");
      expect(hasProp).toHaveBeenCalledWith("aria-selected", attrs);
      expect(result).toBe(true);
    });

    it("returns false and does not call hasProp for unsupported keys", () => {
      const result = hasAriaState(attrs, "unknown-key");
      expect(hasProp).not.toHaveBeenCalled();
      expect(result).toBe(false);
    });
  });

  describe("NON_INTERACTIVE", () => {
    it("includes Text by default", () => {
      expect(NON_INTERACTIVE.has("Text")).toBe(true);
    });
  });
});
