import * as t from "@babel/types";
import pathMod from "path";
import type { NodePath } from "@babel/traverse";
import { stateCode, stateError, stateMap } from "../../constants";
import { hasProp } from "../hasProp";
import { AttrType, FileOptions } from "../../types";
import { hasAriaState, inferFromFilename, inferFromTag, NON_INTERACTIVE } from "./suggestState";
import { isTopLevelJSX } from "../accessibilityRole/suggestRole";

export const auditAccessibilityStates = (
  tag: string,
  attributes: AttrType[],
  path: NodePath<t.JSXElement>,
  filePath: string,
  prComments: any[],
  options?: FileOptions
) => {
  if (NON_INTERACTIVE.has(tag)) return;

  const topLevel = isTopLevelJSX(path);

  const filenameState = topLevel ? inferFromFilename(options?.filePath ?? filePath) : null;

  const tagState = inferFromTag(tag);

  const stateKey = filenameState ?? tagState;
  if (!stateKey) return;

  if (
    filenameState &&                 
    topLevel &&                      
    options?.perFile &&               
    options.perFile.seededFirstLayer === false 
  ) {
    const line = path.node.loc?.start.line || 0;
    prComments.push({
      type: "accessibilityState",
      tag,
      line,
      text: `${stateCode}: Add an accessibilityState to ${filePath}. Suggested: accessibilityState={{ ${stateKey}: ... }}.`,
      location: filePath,
    });
    options.perFile.seededFirstLayer = true;
    return;
  }

  if (hasProp('accessibilityState', attributes) || hasAriaState(attributes, stateKey)) return;

  const line = path.node.loc?.start.line || 0;
  const suggestion =
      `${stateCode}: <${tag}> on line ${line} is missing an accessibilityState. Suggested: accessibilityState={{ ${stateKey}: ... }}.`;

  prComments.push({
    type: "accessibilityState",
    tag,
    line,
    text: suggestion,
    location: filePath,
  });
};
