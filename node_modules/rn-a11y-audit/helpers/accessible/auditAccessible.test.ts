import * as t from "@babel/types";
import type { NodePath } from "@babel/traverse";
import { auditAccessible } from "./auditAccessible";
import { nestingError } from "../../constants";

// Mock the utils the helper relies on
jest.mock("./utils", () => ({
  isAccessibleTrue: jest.fn(),
  hasInteractiveDescendant: jest.fn(),
}));

import { isAccessibleTrue, hasInteractiveDescendant } from "./utils";

const makePath = (line = 10) =>
  ({ node: { loc: { start: { line } } } } as unknown as NodePath<t.JSXElement>);

describe("auditAccessible", () => {
  let prComments: any[];

  beforeEach(() => {
    prComments = [];
    jest.clearAllMocks();
  });

  it("does nothing for non-View tags", () => {
    (isAccessibleTrue as jest.Mock).mockReturnValue(true);
    (hasInteractiveDescendant as jest.Mock).mockReturnValue(true);

    auditAccessible("Text", [], makePath(5), "src/File.tsx", prComments);

    expect(prComments).toHaveLength(0);
    expect(isAccessibleTrue).not.toHaveBeenCalled(); // short-circuits before checking
    expect(hasInteractiveDescendant).not.toHaveBeenCalled();
  });

  it("does nothing when View is not accessible", () => {
    (isAccessibleTrue as jest.Mock).mockReturnValue(false);

    auditAccessible("View", [], makePath(7), "src/Screen.tsx", prComments);

    expect(isAccessibleTrue).toHaveBeenCalledTimes(1);
    expect(hasInteractiveDescendant).not.toHaveBeenCalled();
    expect(prComments).toHaveLength(0);
  });

  it("does nothing when View is accessible but has no interactive descendants", () => {
    (isAccessibleTrue as jest.Mock).mockReturnValue(true);
    (hasInteractiveDescendant as jest.Mock).mockReturnValue(false);

    auditAccessible("View", [], makePath(12), "src/Screen.tsx", prComments);

    expect(isAccessibleTrue).toHaveBeenCalledTimes(1);
    expect(hasInteractiveDescendant).toHaveBeenCalledTimes(1);
    expect(prComments).toHaveLength(0);
  });

  it("adds a PR comment when View is accessible and has interactive descendants", () => {
    (isAccessibleTrue as jest.Mock).mockReturnValue(true);
    (hasInteractiveDescendant as jest.Mock).mockReturnValue(true);

    const path = makePath(20);
    const filePath = "src/Screen.tsx";

    auditAccessible("View", [], path, filePath, prComments);

    expect(isAccessibleTrue).toHaveBeenCalledTimes(1);
    expect(hasInteractiveDescendant).toHaveBeenCalledTimes(1);

    expect(prComments).toHaveLength(1);
    expect(prComments[0]).toEqual({
      type: "accessible",
      tag: "View",
      line: 20,
      text: nestingError,
      location: filePath,
    });
  });

  it("uses the path line number in the comment", () => {
    (isAccessibleTrue as jest.Mock).mockReturnValue(true);
    (hasInteractiveDescendant as jest.Mock).mockReturnValue(true);

    auditAccessible("View", [], makePath(42), "example/File.tsx", prComments);

    expect(prComments[0].line).toBe(42);
  });
});
