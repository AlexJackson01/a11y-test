import * as t from "@babel/types";
import { parse } from "@babel/parser";
import traverse, { NodePath } from "@babel/traverse";
import { isAccessibleTrue, hasInteractiveDescendant } from "./utils";
import { touchables } from "../../constants";

const attr = (name: string, value?: t.JSXAttribute["value"]) =>
  t.jsxAttribute(t.jsxIdentifier(name), value);

const jsxPathOf = (code: string): NodePath<t.JSXElement> => {
  const ast = parse(code, { sourceType: "module", plugins: ["jsx", "typescript"] });
  let found!: NodePath<t.JSXElement>;
  traverse(ast, {
    JSXElement(p) {
      found = p;
      p.stop();
    },
  });
  return found;
};

describe("isAccessibleTrue", () => {
  it("returns false when attribute is missing", () => {
    expect(isAccessibleTrue([])).toBe(false);
  });

  it("returns true for bare boolean attribute (<View accessible />)", () => {
    const attrs = [attr("accessible")];
    expect(isAccessibleTrue(attrs)).toBe(true);
  });

  it('returns true for string literal "true"', () => {
    const attrs = [attr("accessible", t.stringLiteral("true"))];
    expect(isAccessibleTrue(attrs)).toBe(true);
  });

  it('returns false for string literal "false"', () => {
    const attrs = [attr("accessible", t.stringLiteral("false"))];
    expect(isAccessibleTrue(attrs)).toBe(false);
  });

  it("returns true for expression {true}", () => {
    const attrs = [attr("accessible", t.jsxExpressionContainer(t.booleanLiteral(true)))];
    expect(isAccessibleTrue(attrs)).toBe(true);
  });

  it("returns false for expression {false}", () => {
    const attrs = [attr("accessible", t.jsxExpressionContainer(t.booleanLiteral(false)))];
    expect(isAccessibleTrue(attrs)).toBe(false);
  });

  it("returns false for non-boolean expression (e.g., identifier)", () => {
    const attrs = [attr("accessible", t.jsxExpressionContainer(t.identifier("flag")))];
    expect(isAccessibleTrue(attrs)).toBe(false);
  });
});

describe("hasInteractiveDescendant", () => {
  it("returns false when there are no descendants", () => {
    const root = jsxPathOf(`<View />`);
    expect(hasInteractiveDescendant(root)).toBe(false);
  });

  it("returns false when descendants are non-touchable", () => {
    const root = jsxPathOf(`
      <View>
        <Text>Hello</Text>
        <Image />
      </View>
    `);
    expect(hasInteractiveDescendant(root)).toBe(false);
  });

  it("returns true when a touchable descendant exists", () => {
    const anyTouchable = touchables[0] ?? "Pressable";
    const root = jsxPathOf(`
      <View>
        <Text>Intro</Text>
        <${anyTouchable} onPress={() => {}} />
      </View>
    `);
    expect(hasInteractiveDescendant(root)).toBe(true);
  });

  it("returns true for deeply nested touchable descendants", () => {
    const root = jsxPathOf(`
      <View>
        <View>
          <View>
            <TouchableOpacity onPress={() => {}}><Text>Tap</Text></TouchableOpacity>
          </View>
        </View>
      </View>
    `);
    expect(hasInteractiveDescendant(root)).toBe(true);
  });

  it("ignores the root element itself (only checks descendants)", () => {
    // The helper is meant to be called on a <View/>; ensure a root touchable
    // isn't mistaken via traversal. We wrap a Pressable in a parent View.
    const root = jsxPathOf(`<View><Pressable /></View>`);
    expect(hasInteractiveDescendant(root)).toBe(true); // descendant present

    // And just to be explicit: if called *on* the Pressable node itself,
    // it should search its children, which are none -> false.
    const ast = parse(`<Pressable />`, { sourceType: "module", plugins: ["jsx"] });
    let pressablePath!: NodePath<t.JSXElement>;
    traverse(ast, {
      JSXElement(p) {
        pressablePath = p;
        p.stop();
      },
    });
    expect(hasInteractiveDescendant(pressablePath)).toBe(false);
  });
});
