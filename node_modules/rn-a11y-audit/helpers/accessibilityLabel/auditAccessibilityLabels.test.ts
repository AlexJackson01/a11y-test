// auditAccessibilityLabels.test.ts
import { auditAccessibilityLabels } from "./auditAccessibilityLabels";
import { auditImageLabels } from "./auditImageLabels";
import { auditViewLabels } from "./auditViewLabels";
import { auditTouchableLabels } from "./auditTouchableLabels";
import { labelCode } from "../../constants";

// Mock the sub-auditors
jest.mock("./auditImageLabels");
jest.mock("./auditViewLabels");
jest.mock("./auditTouchableLabels");

// Mock hasProp so we can drive the PR-comment branch without real JSX attributes
jest.mock("../hasProp", () => ({
  hasProp: jest.fn(),
}));

import { hasProp } from "../hasProp";

describe("auditAccessibilityLabels", () => {
  const mockPath = {};
  const filePath = "/some/file.tsx";

  beforeEach(() => {
    jest.clearAllMocks();
    jest.spyOn(console, "log").mockImplementation(() => {});
  });

  it("auto-fix pass: calls auditImageLabels for Image and pushes to labelTargets + report", () => {
    const labelResult = { tag: "Image", path: mockPath, text: "Image label" };
    (auditImageLabels as jest.Mock).mockReturnValue(labelResult);

    const labelTargets: any[] = [];
    const report: any[] = [];

    auditAccessibilityLabels(
      "Image",
      [],          // attributes (unused in this branch)
      mockPath,
      filePath,
      labelTargets,
      /* shouldFix */ true,
      report
    );

    expect(auditImageLabels).toHaveBeenCalledWith(expect.anything(), mockPath);
    expect(labelTargets).toContain(labelResult);
    expect(report).toEqual([
      {
        type: "accessibilityLabel",
        tag: "Image",
        text: labelResult.text,
        location: filePath,
      },
    ]);
    // No log in auto-fix pass
    expect(console.log).not.toHaveBeenCalled();
  });

  it("auto-fix pass: calls auditViewLabels for View and pushes to labelTargets + report", () => {
    const labelResult = { tag: "View", path: mockPath, text: "View label" };
    (auditViewLabels as jest.Mock).mockReturnValue(labelResult);

    const labelTargets: any[] = [];
    const report: any[] = [];

    auditAccessibilityLabels(
      "View",
      [],
      mockPath,
      filePath,
      labelTargets,
      /* shouldFix */ true,
      report
    );

    expect(auditViewLabels).toHaveBeenCalledWith("View", expect.anything(), mockPath);
    expect(labelTargets).toContain(labelResult);
    expect(report).toEqual([
      {
        type: "accessibilityLabel",
        tag: "View",
        text: "View label",
        location: filePath,
      },
    ]);
    expect(console.log).not.toHaveBeenCalled();
  });

  it("auto-fix pass: calls auditTouchableLabels for other tags and pushes to labelTargets + report", () => {
    const labelResult = { tag: "Button", path: mockPath, text: "Button label" };
    (auditTouchableLabels as jest.Mock).mockReturnValue(labelResult);

    const labelTargets: any[] = [];
    const report: any[] = [];

    auditAccessibilityLabels(
      "Button",
      [],
      mockPath,
      filePath,
      labelTargets,
      /* shouldFix */ true,
      report
    );

    expect(auditTouchableLabels).toHaveBeenCalledWith("Button", expect.anything(), mockPath);
    expect(labelTargets).toContain(labelResult);
    expect(report).toEqual([
      {
        type: "accessibilityLabel",
        tag: "Button",
        text: "Button label",
        location: filePath,
      },
    ]);
    expect(console.log).not.toHaveBeenCalled();
  });

  it("auto-fix pass: skips pushing when labelResult contains the audit code (non-auto-fixable)", () => {
    const nonAutoFix = { tag: "Button", path: mockPath, text: `${labelCode}: To be reviewed` };
    (auditTouchableLabels as jest.Mock).mockReturnValue(nonAutoFix);

    const labelTargets: any[] = [];
    const report: any[] = [];

    auditAccessibilityLabels(
      "Button",
      [],
      mockPath,
      filePath,
      labelTargets,
      /* shouldFix */ true,
      report
    );

    expect(labelTargets).toHaveLength(0);
    expect(report).toHaveLength(0);
    expect(console.log).not.toHaveBeenCalled();
  });

  it("PR-comment pass: pushes to prComments and logs when missing label & not auto-fixable", () => {
    const prComments: any[] = [];
    const labelResult = { tag: "Pressable", path: mockPath, text: `${labelCode}: Add an accessibilityLabel`, line: 42 };
    (auditTouchableLabels as jest.Mock).mockReturnValue(labelResult);
    (hasProp as jest.Mock).mockReturnValue(false); // simulate no existing accessibilityLabel prop

    const labelTargets: any[] = [];
    const report: any[] = [];

    auditAccessibilityLabels(
      "Pressable",
      [], // attributes are irrelevant because we mocked hasProp
      mockPath,
      filePath,
      labelTargets,
      /* shouldFix */ false,
      report,
      prComments
    );

    expect(prComments).toEqual([
      {
        type: "accessibilityLabel",
        tag: "Pressable",
        line: 42,
        text: `${labelCode}: Add an accessibilityLabel`,
        location: filePath,
      },
    ]);
    expect(labelTargets).toHaveLength(0);
    expect(report).toHaveLength(0);
    expect(console.log).toHaveBeenCalledWith(
      expect.stringContaining(`ðŸŸ¡ ${filePath}: <Pressable> on line 42 missing accessibilityLabel`)
    );
  });

  it("PR-comment pass: does not push when element already has accessibilityLabel", () => {
    const prComments: any[] = [];
    const labelResult = { tag: "Pressable", path: mockPath, text: `${labelCode}: Add an accessibilityLabel`, line: 5 };
    (auditTouchableLabels as jest.Mock).mockReturnValue(labelResult);
    (hasProp as jest.Mock).mockReturnValue(true); // simulate it already has the prop

    const labelTargets: any[] = [];

    auditAccessibilityLabels(
      "Pressable",
      [],
      mockPath,
      filePath,
      labelTargets,
      /* shouldFix */ false,
      /* report */ undefined,
      prComments
    );

    expect(prComments).toHaveLength(0);
    expect(console.log).not.toHaveBeenCalled();
  });

  it("does nothing if sub-auditor returns null", () => {
    (auditTouchableLabels as jest.Mock).mockReturnValue(null);

    const labelTargets: any[] = [];
    const report: any[] = [];
    const prComments: any[] = [];

    auditAccessibilityLabels(
      "Button",
      [],
      mockPath,
      filePath,
      labelTargets,
      /* shouldFix */ true,
      report,
      prComments
    );

    expect(labelTargets).toHaveLength(0);
    expect(report).toHaveLength(0);
    expect(prComments).toHaveLength(0);
    expect(console.log).not.toHaveBeenCalled();
  });
});
