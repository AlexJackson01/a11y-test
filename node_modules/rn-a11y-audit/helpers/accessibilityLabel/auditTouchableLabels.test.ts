import * as t from "@babel/types";
import { auditTouchableLabels } from "./auditTouchableLabels";

const createPath = (
  attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[],
  children: any[] = []
) =>
  ({
    node: {
      openingElement: {
        attributes,
        name: t.jsxIdentifier("TouchableOpacity"), // simulate tag
      },
      children,
    },
    traverse: jest.fn().mockImplementation((visitors) => {
      // Find the JSXElement visitor
      if (visitors.JSXElement) {
        // Create a fake <Text> element with children for extractTextFromJSX fallback
        const innerPath = {
          node: {
            openingElement: {
              name: t.jsxIdentifier("Text"),
            },
            children,
          },
          stop: jest.fn(),
        };

        visitors.JSXElement(innerPath);
      }
    }),
  }) as any;

describe("auditTouchableLabels", () => {
  it("returns null if accessibilityLabel is already present", () => {
    const path = createPath([
      t.jsxAttribute(
        t.jsxIdentifier("accessibilityLabel"),
        t.stringLiteral("Label")
      ),
    ]);

    const result = auditTouchableLabels(
      "Button",
      path.node.openingElement.attributes,
      path
    );
    expect(result).toBeNull();
  });

  it("extracts label from title prop string literal if accessibilityLabel is missing", () => {
    const path = createPath([
      t.jsxAttribute(t.jsxIdentifier("title"), t.stringLiteral("Submit")),
    ]);

    const result = auditTouchableLabels(
      "Button",
      path.node.openingElement.attributes,
      path
    );
    expect(result).toEqual({
      line: 0,
      tag: "Button",
      path,
      text: "Submit",
    });
  });

  it("extracts label from title prop identifier expression like {title}", () => {
    const titleIdentifier = t.jsxAttribute(
      t.jsxIdentifier("title"),
      t.jsxExpressionContainer(t.identifier("title"))
    );

    const path = createPath([titleIdentifier]);

    const result = auditTouchableLabels(
      "Button",
      path.node.openingElement.attributes,
      path
    );
    expect(result).toEqual({
      line: 0,
      tag: "Button",
      path,
      text: "{title}",
    });
  });

  it("extracts label from title prop member expression like {props.title}", () => {
    const memberExpr = t.jsxAttribute(
      t.jsxIdentifier("title"),
      t.jsxExpressionContainer(
        t.memberExpression(t.identifier("props"), t.identifier("title"))
      )
    );

    const path = createPath([memberExpr]);

    const result = auditTouchableLabels(
      "Button",
      path.node.openingElement.attributes,
      path
    );
    expect(result).toEqual({
      line: 0,
      tag: "Button",
      path,
      text: "{props.title}",
    });
  });

  it("extracts label from complex title prop expression (ternary)", () => {
    const ternaryExpr = t.jsxAttribute(
      t.jsxIdentifier("title"),
      t.jsxExpressionContainer(
        t.conditionalExpression(
          t.identifier("cond"),
          t.stringLiteral("Yes"),
          t.stringLiteral("No")
        )
      )
    );

    const path = createPath([ternaryExpr]);

    const result = auditTouchableLabels(
      "Button",
      path.node.openingElement.attributes,
      path
    );
    expect(result?.text).toBe("{cond ? \"Yes\" : \"No\"}");
  });

  it("falls back to extracting text from children inside <Text>", () => {
    const children = [
      {
        type: "JSXText",
        value: "Sample fallback",
        start: 0,
        end: 15,
        loc: {},
      },
    ];

    const path = createPath([], children);

    const result = auditTouchableLabels(
      "TouchableOpacity",
      path.node.openingElement.attributes,
      path
    );

    expect(result?.text).toBe("Sample fallback");
  });

  it("extracts identifier expression inside <Text>", () => {
    const children = [
      {
        type: "JSXExpressionContainer",
        expression: t.identifier("labelVar"),
      },
    ];

    const path = createPath([], children);

    const result = auditTouchableLabels(
      "TouchableOpacity",
      path.node.openingElement.attributes,
      path
    );

    expect(result?.text).toBe("{labelVar}");
  });

  it("extracts complex expression inside <Text>", () => {
    const children = [
      {
        type: "JSXExpressionContainer",
        expression: t.conditionalExpression(
          t.identifier("cond"),
          t.stringLiteral("Yes"),
          t.stringLiteral("No")
        ),
      },
    ];

    const path = createPath([], children);

    const result = auditTouchableLabels(
      "TouchableOpacity",
      path.node.openingElement.attributes,
      path
    );

    expect(result?.text).toBe("{cond ? \"Yes\" : \"No\"}");
  });
});
