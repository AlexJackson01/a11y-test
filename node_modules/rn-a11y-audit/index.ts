#!/usr/bin/env node

import chalk from "chalk";
import fs from "fs";
import path from "path";
import { generateReport } from "./scripts/generateReport";
import { LabelTargets, ReportEntry } from "./types";
import { auditFiles } from "./helpers/auditFiles";
import { prepareComments } from "./helpers/prepareComments";
import { Octokit } from "@octokit/rest";

const report: ReportEntry[] = [];
const prComments: ReportEntry[] = [];

const inputDir = process.argv[2];

const walkDirForFixes = async (dir: string, changedFiles: string[] = []) => {
  const files = fs.readdirSync(dir);

  for (const file of files) {
    const fullPath = path.join(dir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      // Skip common directories
      if (["node_modules", "__tests__", "android", "ios", ".git"].includes(file)) {
        continue;
      }
      await walkDirForFixes(fullPath, changedFiles);
    } else if (fullPath.endsWith(".tsx") || fullPath.endsWith(".jsx")) {
      
      // If we have a list of changed files, only audit those
      if (changedFiles.length > 0) {
        const absolutePath = path.resolve(fullPath);
        if (!changedFiles.includes(absolutePath)) {
          continue; // Skip unchanged files
        }
      }
      
      console.log(chalk.gray(`üîß Applying fixes to: ${fullPath}`));
      
      // Check if file content changes after audit
      const beforeContent = fs.readFileSync(fullPath, 'utf-8');
      
      // Run auditFiles with shouldFix enabled
      await auditFiles(fullPath, report); // Pass true for shouldFix
      
      // Check if fixes were applied
      const afterContent = fs.readFileSync(fullPath, 'utf-8');
      if (beforeContent !== afterContent) {
        console.log(chalk.green(`‚úÖ Applied fixes to: ${fullPath}`));
      } else {
        console.log(chalk.yellow(`‚ö†Ô∏è  No fixes applied to: ${fullPath}`));
      }
    }
  }
};

const walkDirForComments = async (dir: string, changedFiles: string[] = []) => {
  const files = fs.readdirSync(dir);

  for (const file of files) {
    const fullPath = path.join(dir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      // Skip common directories
      if (["node_modules", "__tests__", "android", "ios", ".git"].includes(file)) {
        continue;
      }
      await walkDirForComments(fullPath, changedFiles);
    } else if (fullPath.endsWith(".tsx") || fullPath.endsWith(".jsx")) {
      
      // If we have a list of changed files, only audit those
      if (changedFiles.length > 0) {
        const absolutePath = path.resolve(fullPath);
        if (!changedFiles.includes(absolutePath)) {
          continue; // Skip unchanged files
        }
      }
      
      console.log(chalk.gray(`üìù Checking for unfixable issues in: ${fullPath}`));
      
      // Only run prepareComments (for issues that couldn't be autofixed)
      await prepareComments(fullPath, prComments);
    }
  }
};

// Get list of changed files in the PR
async function getChangedFiles(): Promise<string[]> {
  const token = process.env.GITHUB_TOKEN;
  const prNumber = process.env.PR_NUMBER;
  const repo = process.env.GITHUB_REPOSITORY?.split("/");

  // If not in GitHub PR environment, audit all files
  if (!token || !prNumber || !repo) {
    return [];
  }

  try {
    const octokit = new Octokit({ auth: token });
    const [owner, repoName] = repo;

    const files = await octokit.rest.pulls.listFiles({
      owner,
      repo: repoName,
      pull_number: parseInt(prNumber)
    });

    const changedFiles = files.data
      .filter(file => file.status !== 'removed') // Skip deleted files
      .filter(file => file.filename.endsWith('.tsx') || file.filename.endsWith('.jsx'))
      .map(file => path.resolve(process.cwd(), file.filename));

    console.log(chalk.blue(`üìã Found ${changedFiles.length} changed React Native files in PR`));
    changedFiles.forEach(file => console.log(chalk.gray(`  - ${path.relative(process.cwd(), file)}`)));

    return changedFiles;

  } catch (error) {
    console.error(chalk.red("‚ùå Failed to get changed files, auditing all files:"), error);
    return [];
  }
}

// Transform comments for GitHub API
function transformCommentsForPR(prComments: ReportEntry[]): ReportEntry[] {
  const transformedComments: ReportEntry[] = [];

  for (const comment of prComments) {
    // Get filename from comment.location (from your audit functions)
    let filename = comment.location;
    
    // Convert absolute path to relative path
    if (filename && path.isAbsolute(filename)) {
      filename = path.relative(process.cwd(), filename);
    }
    
    // Skip if no valid filename
    if (!filename) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Skipping comment with missing filename`));
      continue;
    }

    transformedComments.push({
      ...comment,
      location: filename
    });
  }

  return transformedComments;
}

// Check if comment already exists to avoid duplicates
async function findExistingComment(
  octokit: Octokit,
  owner: string,
  repo: string,
  prNumber: number,
  fingerprint: string
): Promise<any> {
  try {
    const comments = await octokit.rest.pulls.listReviewComments({
      owner,
      repo,
      pull_number: prNumber
    });
    
    return comments.data.find(comment => 
      comment.body?.includes(`<!-- a11y-fingerprint:${fingerprint} -->`)
    );
  } catch (error: any) {
    console.warn(chalk.yellow("‚ö†Ô∏è  Could not check for existing comments:"), error.message);
    return null;
  }
}

// Create unique fingerprint for each comment
function createFingerprint(filename: string, line: number, message: string): string {
  const raw = `${filename}:${line}:${message}`;
  const fingerprint = Buffer.from(raw).toString("base64").slice(0, 16);
  console.log(chalk.gray(`üîç Creating fingerprint for ${filename}:${line} -> ${fingerprint}`));
  return fingerprint;
}

// Post comments to GitHub if in PR environment
async function postCommentsIfInPR(comments: ReportEntry[]) {
  const token = process.env.GITHUB_TOKEN;
  const prNumber = process.env.PR_NUMBER;
  const repo = process.env.GITHUB_REPOSITORY?.split("/");

  // If not in GitHub PR environment, skip
  if (!token || !prNumber || !repo) {
    console.log(chalk.gray("‚ÑπÔ∏è  Not in GitHub PR environment - skipping comment posting"));
    return;
  }

  if (comments.length === 0) {
    console.log(chalk.green("üéâ No unfixable accessibility issues found!"));
    return;
  }

  try {
    console.log(chalk.blue("üìù Posting comments for unfixable issues..."));
    
    const octokit = new Octokit({ auth: token });
    const [owner, repoName] = repo;

    // Get PR details for commit SHA
    const prData = await octokit.rest.pulls.get({
      owner,
      repo: repoName,
      pull_number: parseInt(prNumber)
    });
    
    const commitSha = prData.data.head.sha;

    let postedCount = 0;
    let skippedCount = 0;

    // Group comments by file and line to avoid spam
    const groupedComments = comments.reduce((acc, comment) => {
      const key = `${comment.location}:${comment.line}`;
      if (!acc[key]) acc[key] = [];
      acc[key].push(comment);
      return acc;
    }, {} as Record<string, ReportEntry[]>);

    for (const [fileAndLine, issues] of Object.entries(groupedComments)) {
      const [filename, lineStr] = fileAndLine.split(":");
      const line = parseInt(lineStr);
      
      // Create comment body with all issues for this location
      let body;
      if (issues.length === 1) {
        body = `üîç **Accessibility Issue**\n\n${issues[0].text}`;
      } else {
        body = `üîç **Accessibility Issues** (${issues.length} found)\n\n`;
        for (const issue of issues) {
          body += `‚Ä¢ ${issue.text}\n`;
        }
      }

      // Create fingerprint to avoid duplicates
      const fingerprint = createFingerprint(filename, line, issues.map(i => i.text).join("|"));
      
      // Check if we already posted this comment
      const existingComment = await findExistingComment(octokit, owner, repoName, parseInt(prNumber), fingerprint);
      
      if (existingComment) {
        console.log(chalk.gray(`‚è≠Ô∏è  Skipping duplicate comment for ${filename}:${line} (fingerprint: ${fingerprint})`));
        skippedCount++;
        continue;
      }

      try {
        await octokit.rest.pulls.createReviewComment({
          owner,
          repo: repoName,
          pull_number: parseInt(prNumber),
          commit_id: commitSha,
          body: body + `\n\n<!-- a11y-fingerprint:${fingerprint} -->`,
          path: filename,
          line: line,
          side: "RIGHT"
        });
        
        console.log(chalk.green(`‚úÖ Posted comment for ${filename}:${line}`));
        postedCount++;
        
        // Small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error: any) {
        if (error.status === 422) {
          console.log(chalk.yellow(`‚ö†Ô∏è  Could not comment on ${filename}:${line} (file not in PR diff)`));
        } else {
          console.error(chalk.red(`‚ùå Failed to post comment for ${filename}:${line}: ${error.message}`));
        }
      }
    }

    console.log(chalk.green(`üéâ Posted ${postedCount} comments for unfixable issues, skipped ${skippedCount} duplicates`));

  } catch (error: any) {
    console.error(chalk.red("‚ùå Failed to post comments:"), error.message);
    if (error.status === 403) {
      console.log(chalk.yellow("üí° Check that the workflow has 'pull-requests: write' permission"));
    }
  }
}

if (!inputDir) {
  console.log(chalk.red("‚ùå Usage: rn-a11y-audit <path-to-src>"));
  process.exit(1);
}

const targetDir = process.argv[2];

if (!targetDir) {
  console.log(chalk.red("‚ùå Usage: rn-a11y-audit path/to/your/code"));
  console.log(chalk.gray("Example: rn-a11y-audit ./src"));
  process.exit(1);
}

(async () => {
  console.log(chalk.blue("üîç Running React Native accessibility audit..."));
  console.log(chalk.gray(`Scanning: ${targetDir}`));
  
  try {
    // Get list of changed files if in PR environment
    const changedFiles = await getChangedFiles();
    
    console.log(chalk.blue("üîß Step 1: Applying accessibility fixes to changed files..."));
    await walkDirForFixes(targetDir, changedFiles);
    
    console.log(chalk.blue("üìù Step 2: Preparing comments for unfixable issues..."));
    await walkDirForComments(targetDir, changedFiles);

    // Always generate console report
    generateReport(report);

    // Transform comments and save JSON (only for unfixable issues)
    const commentsForPR = transformCommentsForPR(prComments);
    
    const reportsDir = path.join(process.cwd(), "reports");
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }

    const commentsPath = path.join(reportsDir, "comments.json");
    fs.writeFileSync(commentsPath, JSON.stringify(commentsForPR, null, 2));
    
    console.log(chalk.blue(`üìù PR comments written to ${commentsPath}`));
    console.log(chalk.gray(`Found ${commentsForPR.length} unfixable issues to comment on`));

    // Post comments for issues that couldn't be automatically fixed
    await postCommentsIfInPR(commentsForPR);

    console.log(chalk.green("‚úÖ Audit complete"));
    
  } catch (error) {
    console.error(chalk.red("‚ùå Audit failed:"), error instanceof Error ? error.message : error);
    process.exit(1);
  }
})();