#!/usr/bin/env node

import chalk from "chalk";
import fs from "fs";
import path from "path";
import { generateReport } from "./scripts/generateReport";
import { LabelTargets, ReportEntry } from "./types";
import { auditFiles } from "./helpers/auditFiles";
import { prepareComments } from "./helpers/prepareComments";
import { Octokit } from "@octokit/rest";

const report: ReportEntry[] = [];
const prComments: ReportEntry[] = [];

const inputDir = process.argv[2];

const walkDir = async (dir: string) => {
  const files = fs.readdirSync(dir);

  for (const file of files) {
    const fullPath = path.join(dir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      // Skip common directories
      if (["node_modules", "__tests__", "android", "ios", ".git"].includes(file)) {
        continue;
      }
      await walkDir(fullPath);
    } else if (fullPath.endsWith(".tsx") || fullPath.endsWith(".jsx")) {
      console.log(chalk.gray(`üîç Auditing: ${fullPath}`));
      
      // Store file content before audit to check if it changed
      const beforeContent = fs.readFileSync(fullPath, 'utf-8');
      
      await auditFiles(fullPath, report);
      await prepareComments(fullPath, prComments);
      
      // Check if file was modified by fixes
      const afterContent = fs.readFileSync(fullPath, 'utf-8');
      if (beforeContent !== afterContent) {
        console.log(chalk.green(`‚úÖ Applied fixes to: ${fullPath}`));
      }
    }
  }
};

// Transform comments for GitHub API
function transformCommentsForPR(prComments: ReportEntry[]): ReportEntry[] {
  const transformedComments: ReportEntry[] = [];

  for (const comment of prComments) {
    // Get filename from comment.location
    let filename = comment.location;
    
    // Convert absolute path to relative path
    if (filename && path.isAbsolute(filename)) {
      filename = path.relative(process.cwd(), filename);
    }
    
    // Skip if no valid filename
    if (!filename) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Skipping comment with missing filename`));
      continue;
    }

    transformedComments.push({
      ...comment,
      location: filename
    });
  }

  return transformedComments;
}

// Check if comment already exists to avoid duplicates
async function findExistingComment(
  octokit: Octokit,
  owner: string,
  repo: string,
  prNumber: number,
  fingerprint: string
): Promise<any> {
  try {
    const comments = await octokit.rest.pulls.listReviewComments({
      owner,
      repo,
      pull_number: prNumber
    });
    
    return comments.data.find(comment => 
      comment.body?.includes(`<!-- a11y-fingerprint:${fingerprint} -->`)
    );
  } catch (error: any) {
    console.warn(chalk.yellow("‚ö†Ô∏è  Could not check for existing comments:"), error.message);
    return null;
  }
}

// Create unique fingerprint for each comment
function createFingerprint(filename: string, line: number, message: string): string {
  const raw = `${filename}:${line}:${message}`;
  return Buffer.from(raw).toString("base64").slice(0, 16);
}

// Post summary comment for files not in PR diff
async function postSummaryComment(
  octokit: Octokit, 
  owner: string, 
  repo: string, 
  prNumber: number, 
  comments: ReportEntry[]
) {
  const groupedByFile = comments.reduce((acc, comment) => {
    if (!acc[comment.location]) acc[comment.location] = [];
    acc[comment.location].push(comment);
    return acc;
  }, {} as Record<string, ReportEntry[]>);

  let summaryBody = `## üîç Accessibility Issues in Unchanged Files\n\n`;
  summaryBody += `Found ${comments.length} accessibility issues in files that weren't modified in this PR:\n\n`;

  for (const [file, fileComments] of Object.entries(groupedByFile)) {
    summaryBody += `### üìÑ ${file}\n`;
    for (const comment of fileComments) {
      summaryBody += `- **Line ${comment.line}**: ${comment.text}\n`;
    }
    summaryBody += `\n`;
  }

  summaryBody += `---\n*These issues exist in your codebase but aren't part of this PR's changes. Consider addressing them in a future PR.*`;

  try {
    await octokit.rest.issues.createComment({
      owner,
      repo,
      issue_number: prNumber,
      body: summaryBody
    });
    
    console.log(chalk.green(`‚úÖ Posted summary comment for ${comments.length} issues in unchanged files`));
  } catch (error: any) {
    console.error(chalk.red(`‚ùå Failed to post summary comment: ${error.message}`));
  }
}

// Commit any fixes back to the PR branch
async function commitFixesIfNeeded() {
  const token = process.env.GITHUB_TOKEN;
  const prNumber = process.env.PR_NUMBER;
  const repo = process.env.GITHUB_REPOSITORY?.split("/");
  const branchName = process.env.BRANCH_NAME;

  // Only commit in GitHub PR environment
  if (!token || !prNumber || !repo || !branchName) {
    console.log(chalk.gray("‚ÑπÔ∏è  Not in GitHub PR environment - skipping auto-commit"));
    return;
  }

  try {
    const { execSync } = require('child_process');
    
    const execOptions = { maxBuffer: 1024 * 1024 * 10 }; // 10MB buffer
    
    // Check if there are changes to commit
    let hasChanges = false;
    try {
      execSync('git diff --quiet', execOptions);
      // No changes
    } catch {
      // There are changes
      hasChanges = true;
    }
    
    if (!hasChanges) {
      console.log(chalk.gray("‚ÑπÔ∏è  No changes to commit"));
      return;
    }
    
    console.log(chalk.blue("üì§ Committing accessibility fixes..."));
    
    // Stage changes
    execSync('git add .', execOptions);
    
    // Commit changes
    execSync('git commit -m "üîß Apply accessibility fixes"', execOptions);
    
    // Push to the correct branch
    execSync(`git push origin HEAD:${branchName}`, execOptions);
    
    console.log(chalk.green("‚úÖ Committed accessibility fixes to PR"));
    
  } catch (error: any) {
    console.error(chalk.red("‚ùå Failed to commit changes:"), error.message);
    console.log(chalk.yellow("üí° This might be due to no changes to commit or git permissions"));
    
    // Try to show what changes exist
    try {
      const { execSync } = require('child_process');
      const status = execSync('git status --porcelain', { encoding: 'utf8', maxBuffer: 1024 * 1024 });
      if (status.trim()) {
        console.log(chalk.blue("üìã Detected changes:"));
        console.log(status);
      } else {
        console.log(chalk.gray("‚ÑπÔ∏è  No changes detected by git status"));
      }
    } catch (statusError) {
      console.log(chalk.yellow("‚ö†Ô∏è  Could not check git status"));
    }
  }
}

// Post comments to GitHub if in PR environment
async function postCommentsIfInPR(comments: ReportEntry[]) {
  const token = process.env.GITHUB_TOKEN;
  const prNumber = process.env.PR_NUMBER;
  const repo = process.env.GITHUB_REPOSITORY?.split("/");

  // If not in GitHub PR environment, skip
  if (!token || !prNumber || !repo) {
    console.log(chalk.gray("‚ÑπÔ∏è  Not in GitHub PR environment - skipping comment posting"));
    return;
  }

  if (comments.length === 0) {
    console.log(chalk.green("üéâ No accessibility issues to comment on!"));
    return;
  }

  try {
    console.log(chalk.blue("üìù Posting comments to GitHub PR..."));
    
    const octokit = new Octokit({ auth: token });
    const [owner, repoName] = repo;

    // Get PR details for commit SHA
    const prData = await octokit.rest.pulls.get({
      owner,
      repo: repoName,
      pull_number: parseInt(prNumber)
    });
    
    const commitSha = prData.data.head.sha;

    let postedCount = 0;
    let skippedCount = 0;
    const failedComments: ReportEntry[] = [];

    // Group comments by file and line to avoid spam
    const groupedComments = comments.reduce((acc, comment) => {
      const key = `${comment.location}:${comment.line}`;
      if (!acc[key]) acc[key] = [];
      acc[key].push(comment);
      return acc;
    }, {} as Record<string, ReportEntry[]>);

    for (const [fileAndLine, issues] of Object.entries(groupedComments)) {
      const [filename, lineStr] = fileAndLine.split(":");
      const line = parseInt(lineStr);
      
      // Create comment body with all issues for this location
      let body;
      if (issues.length === 1) {
        body = `üîç **Accessibility Issue**\n\n${issues[0].text}`;
      } else {
        body = `üîç **Accessibility Issues** (${issues.length} found)\n\n`;
        for (const issue of issues) {
          body += `‚Ä¢ ${issue.text}\n`;
        }
      }

      // Create fingerprint to avoid duplicates
      const fingerprint = createFingerprint(filename, line, issues.map(i => i.text).join("|"));
      
      // Check if we already posted this comment
      const existingComment = await findExistingComment(octokit, owner, repoName, parseInt(prNumber), fingerprint);
      
      if (existingComment) {
        console.log(chalk.gray(`‚è≠Ô∏è  Skipping duplicate comment for ${filename}:${line}`));
        skippedCount++;
        continue;
      }

      try {
        await octokit.rest.pulls.createReviewComment({
          owner,
          repo: repoName,
          pull_number: parseInt(prNumber),
          commit_id: commitSha,
          body: body + `\n\n<!-- a11y-fingerprint:${fingerprint} -->`,
          path: filename,
          line: line,
          side: "RIGHT"
        });
        
        console.log(chalk.green(`‚úÖ Posted comment for ${filename}:${line}`));
        postedCount++;
        
        // Small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error: any) {
        if (error.status === 422) {
          console.log(chalk.yellow(`‚ö†Ô∏è  Could not comment on ${filename}:${line} (file not in PR diff)`));
          failedComments.push(...issues);
        } else {
          console.error(chalk.red(`‚ùå Failed to post comment for ${filename}:${line}: ${error.message}`));
        }
      }
    }

    // Post summary comment for files not in diff
    if (failedComments.length > 0) {
      await postSummaryComment(octokit, owner, repoName, parseInt(prNumber), failedComments);
    }

    console.log(chalk.green(`üéâ Posted ${postedCount} line comments, skipped ${skippedCount} duplicates`));
    if (failedComments.length > 0) {
      console.log(chalk.blue(`üìã Posted summary comment for ${failedComments.length} issues in unchanged files`));
    }

  } catch (error: any) {
    console.error(chalk.red("‚ùå Failed to post comments:"), error.message);
    if (error.status === 403) {
      console.log(chalk.yellow("üí° Check that the workflow has 'pull-requests: write' permission"));
    }
  }
}

// Commit changes back to the PR branch
async function commitChanges() {
  const token = process.env.GITHUB_TOKEN;
  const prNumber = process.env.PR_NUMBER;
  const repo = process.env.GITHUB_REPOSITORY?.split("/");

  if (!token || !prNumber || !repo) {
    console.log(chalk.gray("‚ÑπÔ∏è  Not in GitHub PR environment - skipping auto-commit"));
    return;
  }

  try {
    console.log(chalk.blue("üì§ Committing accessibility fixes..."));
    
    const octokit = new Octokit({ auth: token });
    const [owner, repoName] = repo;

    // Configure git
    const { execSync } = require('child_process');
    execSync('git config user.name "RN A11y Audit Bot"');
    execSync('git config user.email "a11y-audit@users.noreply.github.com"');
    
    // Check if there are changes to commit
    try {
      execSync('git diff --quiet');
      console.log(chalk.gray("‚ÑπÔ∏è  No changes to commit"));
      return;
    } catch {
      // There are changes - continue with commit
    }
    
    // Stage and commit changes
    execSync('git add .');
    execSync('git commit -m "üîß Apply accessibility fixes from audit"');
    execSync('git push');
    
    console.log(chalk.green("‚úÖ Committed accessibility fixes to PR"));
    
  } catch (error: any) {
    console.error(chalk.red("‚ùå Failed to commit changes:"), error.message);
  }
}

if (!inputDir) {
  console.log(chalk.red("‚ùå Usage: rn-a11y-audit <path-to-src>"));
  process.exit(1);
}

const targetDir = process.argv[2];

if (!targetDir) {
  console.log(chalk.red("‚ùå Usage: rn-a11y-audit path/to/your/code"));
  console.log(chalk.gray("Example: rn-a11y-audit ./src"));
  process.exit(1);
}

(async () => {
  console.log(chalk.blue("üîç Running React Native accessibility audit..."));
  console.log(chalk.gray(`Scanning: ${targetDir}`));
  
  try {
    await walkDir(targetDir);

    // Always generate console report
    generateReport(report);

    // Commit any fixes that were applied
    await commitFixesIfNeeded();

    // Transform comments and save JSON
    const commentsForPR = transformCommentsForPR(prComments);
    
    const reportsDir = path.join(process.cwd(), "reports");
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }

    const commentsPath = path.join(reportsDir, "comments.json");
    fs.writeFileSync(commentsPath, JSON.stringify(commentsForPR, null, 2));
    
    console.log(chalk.blue(`üìù PR comments written to ${commentsPath}`));
    console.log(chalk.gray(`Found ${commentsForPR.length} comments to post`));

    // Post to GitHub if in PR environment
    await postCommentsIfInPR(commentsForPR);

    console.log(chalk.green("‚úÖ Audit complete"));
    
  } catch (error) {
    console.error(chalk.red("‚ùå Audit failed:"), error instanceof Error ? error.message : error);
    process.exit(1);
  }
})();