#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const generateReport_1 = require("./scripts/generateReport");
const auditFiles_1 = require("./helpers/auditFiles");
const prepareComments_1 = require("./helpers/prepareComments");
const rest_1 = require("@octokit/rest");
const report = [];
const prComments = [];
const inputDir = process.argv[2];
const walkDirForFixes = async (dir, changedFiles = []) => {
    const files = fs_1.default.readdirSync(dir);
    for (const file of files) {
        const fullPath = path_1.default.join(dir, file);
        if (fs_1.default.statSync(fullPath).isDirectory()) {
            // Skip common directories
            if (["node_modules", "__tests__", "android", "ios", ".git"].includes(file)) {
                continue;
            }
            await walkDirForFixes(fullPath, changedFiles);
        }
        else if (fullPath.endsWith(".tsx") || fullPath.endsWith(".jsx")) {
            // If we have a list of changed files, only audit those
            if (changedFiles.length > 0) {
                const absolutePath = path_1.default.resolve(fullPath);
                if (!changedFiles.includes(absolutePath)) {
                    continue; // Skip unchanged files
                }
            }
            console.log(chalk_1.default.gray(`üîß Applying fixes to: ${fullPath}`));
            // Check if file content changes after audit
            const beforeContent = fs_1.default.readFileSync(fullPath, 'utf-8');
            // Run auditFiles with shouldFix enabled
            await (0, auditFiles_1.auditFiles)(fullPath, report); // Pass true for shouldFix
            // Check if fixes were applied
            const afterContent = fs_1.default.readFileSync(fullPath, 'utf-8');
            if (beforeContent !== afterContent) {
                console.log(chalk_1.default.green(`‚úÖ Applied fixes to: ${fullPath}`));
            }
            else {
                console.log(chalk_1.default.yellow(`‚ö†Ô∏è  No fixes applied to: ${fullPath}`));
            }
        }
    }
};
const walkDirForComments = async (dir, changedFiles = []) => {
    const files = fs_1.default.readdirSync(dir);
    for (const file of files) {
        const fullPath = path_1.default.join(dir, file);
        if (fs_1.default.statSync(fullPath).isDirectory()) {
            // Skip common directories
            if (["node_modules", "__tests__", "android", "ios", ".git"].includes(file)) {
                continue;
            }
            await walkDirForComments(fullPath, changedFiles);
        }
        else if (fullPath.endsWith(".tsx") || fullPath.endsWith(".jsx")) {
            // If we have a list of changed files, only audit those
            if (changedFiles.length > 0) {
                const absolutePath = path_1.default.resolve(fullPath);
                if (!changedFiles.includes(absolutePath)) {
                    continue; // Skip unchanged files
                }
            }
            console.log(chalk_1.default.gray(`üìù Checking for unfixable issues in: ${fullPath}`));
            // Only run prepareComments (for issues that couldn't be autofixed)
            await (0, prepareComments_1.prepareComments)(fullPath, prComments);
        }
    }
};
// Get list of changed files in the PR
async function getChangedFiles() {
    const token = process.env.GITHUB_TOKEN;
    const prNumber = process.env.PR_NUMBER;
    const repo = process.env.GITHUB_REPOSITORY?.split("/");
    // If not in GitHub PR environment, audit all files
    if (!token || !prNumber || !repo) {
        return [];
    }
    try {
        const octokit = new rest_1.Octokit({ auth: token });
        const [owner, repoName] = repo;
        const files = await octokit.rest.pulls.listFiles({
            owner,
            repo: repoName,
            pull_number: parseInt(prNumber)
        });
        const changedFiles = files.data
            .filter(file => file.status !== 'removed') // Skip deleted files
            .filter(file => file.filename.endsWith('.tsx') || file.filename.endsWith('.jsx'))
            .map(file => path_1.default.resolve(process.cwd(), file.filename));
        console.log(chalk_1.default.blue(`üìã Found ${changedFiles.length} changed React Native files in PR`));
        changedFiles.forEach(file => console.log(chalk_1.default.gray(`  - ${path_1.default.relative(process.cwd(), file)}`)));
        return changedFiles;
    }
    catch (error) {
        console.error(chalk_1.default.red("‚ùå Failed to get changed files, auditing all files:"), error);
        return [];
    }
}
// Transform comments for GitHub API
function transformCommentsForPR(prComments) {
    const transformedComments = [];
    for (const comment of prComments) {
        // Get filename from comment.location (from your audit functions)
        let filename = comment.location;
        // Convert absolute path to relative path
        if (filename && path_1.default.isAbsolute(filename)) {
            filename = path_1.default.relative(process.cwd(), filename);
        }
        // Skip if no valid filename
        if (!filename) {
            console.warn(chalk_1.default.yellow(`‚ö†Ô∏è  Skipping comment with missing filename`));
            continue;
        }
        transformedComments.push({
            ...comment,
            location: filename
        });
    }
    return transformedComments;
}
// Check if comment already exists to avoid duplicates
async function findExistingComment(octokit, owner, repo, prNumber, fingerprint) {
    try {
        const comments = await octokit.rest.pulls.listReviewComments({
            owner,
            repo,
            pull_number: prNumber
        });
        return comments.data.find(comment => comment.body?.includes(`<!-- a11y-fingerprint:${fingerprint} -->`));
    }
    catch (error) {
        console.warn(chalk_1.default.yellow("‚ö†Ô∏è  Could not check for existing comments:"), error.message);
        return null;
    }
}
// Create unique fingerprint for each comment
function createFingerprint(filename, line, message) {
    const raw = `${filename}:${line}:${message}`;
    const fingerprint = Buffer.from(raw).toString("base64").slice(0, 16);
    console.log(chalk_1.default.gray(`üîç Creating fingerprint for ${filename}:${line} -> ${fingerprint}`));
    return fingerprint;
}
// Post comments to GitHub if in PR environment
async function postCommentsIfInPR(comments) {
    const token = process.env.GITHUB_TOKEN;
    const prNumber = process.env.PR_NUMBER;
    const repo = process.env.GITHUB_REPOSITORY?.split("/");
    // If not in GitHub PR environment, skip
    if (!token || !prNumber || !repo) {
        console.log(chalk_1.default.gray("‚ÑπÔ∏è  Not in GitHub PR environment - skipping comment posting"));
        return;
    }
    if (comments.length === 0) {
        console.log(chalk_1.default.green("üéâ No unfixable accessibility issues found!"));
        return;
    }
    try {
        console.log(chalk_1.default.blue("üìù Posting comments for unfixable issues..."));
        const octokit = new rest_1.Octokit({ auth: token });
        const [owner, repoName] = repo;
        // Get PR details for commit SHA
        const prData = await octokit.rest.pulls.get({
            owner,
            repo: repoName,
            pull_number: parseInt(prNumber)
        });
        const commitSha = prData.data.head.sha;
        let postedCount = 0;
        let skippedCount = 0;
        // Group comments by file and line to avoid spam
        const groupedComments = comments.reduce((acc, comment) => {
            const key = `${comment.location}:${comment.line}`;
            if (!acc[key])
                acc[key] = [];
            acc[key].push(comment);
            return acc;
        }, {});
        for (const [fileAndLine, issues] of Object.entries(groupedComments)) {
            const [filename, lineStr] = fileAndLine.split(":");
            const line = parseInt(lineStr);
            // Create comment body with all issues for this location
            let body;
            if (issues.length === 1) {
                body = `üîç **Accessibility Issue**\n\n${issues[0].text}`;
            }
            else {
                body = `üîç **Accessibility Issues** (${issues.length} found)\n\n`;
                for (const issue of issues) {
                    body += `‚Ä¢ ${issue.text}\n`;
                }
            }
            // Create fingerprint to avoid duplicates
            const fingerprint = createFingerprint(filename, line, issues.map(i => i.text).join("|"));
            // Check if we already posted this comment
            const existingComment = await findExistingComment(octokit, owner, repoName, parseInt(prNumber), fingerprint);
            if (existingComment) {
                console.log(chalk_1.default.gray(`‚è≠Ô∏è  Skipping duplicate comment for ${filename}:${line} (fingerprint: ${fingerprint})`));
                skippedCount++;
                continue;
            }
            try {
                await octokit.rest.pulls.createReviewComment({
                    owner,
                    repo: repoName,
                    pull_number: parseInt(prNumber),
                    commit_id: commitSha,
                    body: body + `\n\n<!-- a11y-fingerprint:${fingerprint} -->`,
                    path: filename,
                    line: line,
                    side: "RIGHT"
                });
                console.log(chalk_1.default.green(`‚úÖ Posted comment for ${filename}:${line}`));
                postedCount++;
                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            catch (error) {
                if (error.status === 422) {
                    console.log(chalk_1.default.yellow(`‚ö†Ô∏è  Could not comment on ${filename}:${line} (file not in PR diff)`));
                }
                else {
                    console.error(chalk_1.default.red(`‚ùå Failed to post comment for ${filename}:${line}: ${error.message}`));
                }
            }
        }
        console.log(chalk_1.default.green(`üéâ Posted ${postedCount} comments for unfixable issues, skipped ${skippedCount} duplicates`));
    }
    catch (error) {
        console.error(chalk_1.default.red("‚ùå Failed to post comments:"), error.message);
        if (error.status === 403) {
            console.log(chalk_1.default.yellow("üí° Check that the workflow has 'pull-requests: write' permission"));
        }
    }
}
if (!inputDir) {
    console.log(chalk_1.default.red("‚ùå Usage: rn-a11y-audit <path-to-src>"));
    process.exit(1);
}
const targetDir = process.argv[2];
if (!targetDir) {
    console.log(chalk_1.default.red("‚ùå Usage: rn-a11y-audit path/to/your/code"));
    console.log(chalk_1.default.gray("Example: rn-a11y-audit ./src"));
    process.exit(1);
}
(async () => {
    console.log(chalk_1.default.blue("üîç Running React Native accessibility audit..."));
    console.log(chalk_1.default.gray(`Scanning: ${targetDir}`));
    try {
        // Get list of changed files if in PR environment
        const changedFiles = await getChangedFiles();
        console.log(chalk_1.default.blue("üîß Step 1: Applying accessibility fixes to changed files..."));
        await walkDirForFixes(targetDir, changedFiles);
        console.log(chalk_1.default.blue("üìù Step 2: Preparing comments for unfixable issues..."));
        await walkDirForComments(targetDir, changedFiles);
        // Always generate console report
        (0, generateReport_1.generateReport)(report);
        // Transform comments and save JSON (only for unfixable issues)
        const commentsForPR = transformCommentsForPR(prComments);
        const reportsDir = path_1.default.join(process.cwd(), "reports");
        if (!fs_1.default.existsSync(reportsDir)) {
            fs_1.default.mkdirSync(reportsDir, { recursive: true });
        }
        const commentsPath = path_1.default.join(reportsDir, "comments.json");
        fs_1.default.writeFileSync(commentsPath, JSON.stringify(commentsForPR, null, 2));
        console.log(chalk_1.default.blue(`üìù PR comments written to ${commentsPath}`));
        console.log(chalk_1.default.gray(`Found ${commentsForPR.length} unfixable issues to comment on`));
        // Post comments for issues that couldn't be automatically fixed
        await postCommentsIfInPR(commentsForPR);
        console.log(chalk_1.default.green("‚úÖ Audit complete"));
    }
    catch (error) {
        console.error(chalk_1.default.red("‚ùå Audit failed:"), error instanceof Error ? error.message : error);
        process.exit(1);
    }
})();
//# sourceMappingURL=index.js.map