#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const generateReport_1 = require("./scripts/generateReport");
const auditFiles_1 = require("./helpers/auditFiles");
const prepareComments_1 = require("./helpers/prepareComments");
const rest_1 = require("@octokit/rest");
const report = [];
const prComments = [];
const inputDir = process.argv[2];
const walkDir = async (dir) => {
    const files = fs_1.default.readdirSync(dir);
    for (const file of files) {
        const fullPath = path_1.default.join(dir, file);
        if (fs_1.default.statSync(fullPath).isDirectory()) {
            // Skip common directories
            if (["node_modules", "__tests__", "android", "ios", ".git"].includes(file)) {
                continue;
            }
            await walkDir(fullPath);
        }
        else if (fullPath.endsWith(".tsx") || fullPath.endsWith(".jsx")) {
            console.log(chalk_1.default.gray(`üîç Auditing: ${fullPath}`));
            // Store file content before audit to check if it changed
            const beforeContent = fs_1.default.readFileSync(fullPath, 'utf-8');
            await (0, auditFiles_1.auditFiles)(fullPath, report);
            await (0, prepareComments_1.prepareComments)(fullPath, prComments);
            // Check if file was modified by fixes
            const afterContent = fs_1.default.readFileSync(fullPath, 'utf-8');
            if (beforeContent !== afterContent) {
                console.log(chalk_1.default.green(`‚úÖ Applied fixes to: ${fullPath}`));
            }
        }
    }
};
// Transform comments for GitHub API
function transformCommentsForPR(prComments) {
    const transformedComments = [];
    for (const comment of prComments) {
        // Get filename from comment.location
        let filename = comment.location;
        // Convert absolute path to relative path
        if (filename && path_1.default.isAbsolute(filename)) {
            filename = path_1.default.relative(process.cwd(), filename);
        }
        // Skip if no valid filename
        if (!filename) {
            console.warn(chalk_1.default.yellow(`‚ö†Ô∏è  Skipping comment with missing filename`));
            continue;
        }
        transformedComments.push({
            ...comment,
            location: filename
        });
    }
    return transformedComments;
}
// Check if comment already exists to avoid duplicates
async function findExistingComment(octokit, owner, repo, prNumber, fingerprint) {
    try {
        const comments = await octokit.rest.pulls.listReviewComments({
            owner,
            repo,
            pull_number: prNumber
        });
        return comments.data.find(comment => comment.body?.includes(`<!-- a11y-fingerprint:${fingerprint} -->`));
    }
    catch (error) {
        console.warn(chalk_1.default.yellow("‚ö†Ô∏è  Could not check for existing comments:"), error.message);
        return null;
    }
}
// Create unique fingerprint for each comment
function createFingerprint(filename, line, message) {
    const raw = `${filename}:${line}:${message}`;
    return Buffer.from(raw).toString("base64").slice(0, 16);
}
// Post summary comment for files not in PR diff
async function postSummaryComment(octokit, owner, repo, prNumber, comments) {
    const groupedByFile = comments.reduce((acc, comment) => {
        if (!acc[comment.location])
            acc[comment.location] = [];
        acc[comment.location].push(comment);
        return acc;
    }, {});
    let summaryBody = `## üîç Accessibility Issues in Unchanged Files\n\n`;
    summaryBody += `Found ${comments.length} accessibility issues in files that weren't modified in this PR:\n\n`;
    for (const [file, fileComments] of Object.entries(groupedByFile)) {
        summaryBody += `### üìÑ ${file}\n`;
        for (const comment of fileComments) {
            summaryBody += `- **Line ${comment.line}**: ${comment.text}\n`;
        }
        summaryBody += `\n`;
    }
    summaryBody += `---\n*These issues exist in your codebase but aren't part of this PR's changes. Consider addressing them in a future PR.*`;
    try {
        await octokit.rest.issues.createComment({
            owner,
            repo,
            issue_number: prNumber,
            body: summaryBody
        });
        console.log(chalk_1.default.green(`‚úÖ Posted summary comment for ${comments.length} issues in unchanged files`));
    }
    catch (error) {
        console.error(chalk_1.default.red(`‚ùå Failed to post summary comment: ${error.message}`));
    }
}
// Commit any fixes back to the PR branch
async function commitFixesIfNeeded() {
    const token = process.env.GITHUB_TOKEN;
    const prNumber = process.env.PR_NUMBER;
    const repo = process.env.GITHUB_REPOSITORY?.split("/");
    const branchName = process.env.BRANCH_NAME;
    // Only commit in GitHub PR environment
    if (!token || !prNumber || !repo || !branchName) {
        console.log(chalk_1.default.gray("‚ÑπÔ∏è  Not in GitHub PR environment - skipping auto-commit"));
        return;
    }
    try {
        const { execSync } = require('child_process');
        const execOptions = { maxBuffer: 1024 * 1024 * 10 }; // 10MB buffer
        // Check if there are changes to commit
        let hasChanges = false;
        try {
            execSync('git diff --quiet', execOptions);
            // No changes
        }
        catch {
            // There are changes
            hasChanges = true;
        }
        if (!hasChanges) {
            console.log(chalk_1.default.gray("‚ÑπÔ∏è  No changes to commit"));
            return;
        }
        console.log(chalk_1.default.blue("üì§ Committing accessibility fixes..."));
        // Stage changes
        execSync('git add .', execOptions);
        // Commit changes
        execSync('git commit -m "üîß Apply accessibility fixes"', execOptions);
        // Push to the correct branch
        execSync(`git push origin HEAD:${branchName}`, execOptions);
        console.log(chalk_1.default.green("‚úÖ Committed accessibility fixes to PR"));
    }
    catch (error) {
        console.error(chalk_1.default.red("‚ùå Failed to commit changes:"), error.message);
        console.log(chalk_1.default.yellow("üí° This might be due to no changes to commit or git permissions"));
        // Try to show what changes exist
        try {
            const { execSync } = require('child_process');
            const status = execSync('git status --porcelain', { encoding: 'utf8', maxBuffer: 1024 * 1024 });
            if (status.trim()) {
                console.log(chalk_1.default.blue("üìã Detected changes:"));
                console.log(status);
            }
            else {
                console.log(chalk_1.default.gray("‚ÑπÔ∏è  No changes detected by git status"));
            }
        }
        catch (statusError) {
            console.log(chalk_1.default.yellow("‚ö†Ô∏è  Could not check git status"));
        }
    }
}
// Post comments to GitHub if in PR environment
async function postCommentsIfInPR(comments) {
    const token = process.env.GITHUB_TOKEN;
    const prNumber = process.env.PR_NUMBER;
    const repo = process.env.GITHUB_REPOSITORY?.split("/");
    // If not in GitHub PR environment, skip
    if (!token || !prNumber || !repo) {
        console.log(chalk_1.default.gray("‚ÑπÔ∏è  Not in GitHub PR environment - skipping comment posting"));
        return;
    }
    if (comments.length === 0) {
        console.log(chalk_1.default.green("üéâ No accessibility issues to comment on!"));
        return;
    }
    try {
        console.log(chalk_1.default.blue("üìù Posting comments to GitHub PR..."));
        const octokit = new rest_1.Octokit({ auth: token });
        const [owner, repoName] = repo;
        // Get PR details for commit SHA
        const prData = await octokit.rest.pulls.get({
            owner,
            repo: repoName,
            pull_number: parseInt(prNumber)
        });
        const commitSha = prData.data.head.sha;
        let postedCount = 0;
        let skippedCount = 0;
        const failedComments = [];
        // Group comments by file and line to avoid spam
        const groupedComments = comments.reduce((acc, comment) => {
            const key = `${comment.location}:${comment.line}`;
            if (!acc[key])
                acc[key] = [];
            acc[key].push(comment);
            return acc;
        }, {});
        for (const [fileAndLine, issues] of Object.entries(groupedComments)) {
            const [filename, lineStr] = fileAndLine.split(":");
            const line = parseInt(lineStr);
            // Create comment body with all issues for this location
            let body;
            if (issues.length === 1) {
                body = `üîç **Accessibility Issue**\n\n${issues[0].text}`;
            }
            else {
                body = `üîç **Accessibility Issues** (${issues.length} found)\n\n`;
                for (const issue of issues) {
                    body += `‚Ä¢ ${issue.text}\n`;
                }
            }
            // Create fingerprint to avoid duplicates
            const fingerprint = createFingerprint(filename, line, issues.map(i => i.text).join("|"));
            // Check if we already posted this comment
            const existingComment = await findExistingComment(octokit, owner, repoName, parseInt(prNumber), fingerprint);
            if (existingComment) {
                console.log(chalk_1.default.gray(`‚è≠Ô∏è  Skipping duplicate comment for ${filename}:${line}`));
                skippedCount++;
                continue;
            }
            try {
                await octokit.rest.pulls.createReviewComment({
                    owner,
                    repo: repoName,
                    pull_number: parseInt(prNumber),
                    commit_id: commitSha,
                    body: body + `\n\n<!-- a11y-fingerprint:${fingerprint} -->`,
                    path: filename,
                    line: line,
                    side: "RIGHT"
                });
                console.log(chalk_1.default.green(`‚úÖ Posted comment for ${filename}:${line}`));
                postedCount++;
                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            catch (error) {
                if (error.status === 422) {
                    console.log(chalk_1.default.yellow(`‚ö†Ô∏è  Could not comment on ${filename}:${line} (file not in PR diff)`));
                    failedComments.push(...issues);
                }
                else {
                    console.error(chalk_1.default.red(`‚ùå Failed to post comment for ${filename}:${line}: ${error.message}`));
                }
            }
        }
        // Post summary comment for files not in diff
        if (failedComments.length > 0) {
            await postSummaryComment(octokit, owner, repoName, parseInt(prNumber), failedComments);
        }
        console.log(chalk_1.default.green(`üéâ Posted ${postedCount} line comments, skipped ${skippedCount} duplicates`));
        if (failedComments.length > 0) {
            console.log(chalk_1.default.blue(`üìã Posted summary comment for ${failedComments.length} issues in unchanged files`));
        }
    }
    catch (error) {
        console.error(chalk_1.default.red("‚ùå Failed to post comments:"), error.message);
        if (error.status === 403) {
            console.log(chalk_1.default.yellow("üí° Check that the workflow has 'pull-requests: write' permission"));
        }
    }
}
// Commit changes back to the PR branch
async function commitChanges() {
    const token = process.env.GITHUB_TOKEN;
    const prNumber = process.env.PR_NUMBER;
    const repo = process.env.GITHUB_REPOSITORY?.split("/");
    if (!token || !prNumber || !repo) {
        console.log(chalk_1.default.gray("‚ÑπÔ∏è  Not in GitHub PR environment - skipping auto-commit"));
        return;
    }
    try {
        console.log(chalk_1.default.blue("üì§ Committing accessibility fixes..."));
        const octokit = new rest_1.Octokit({ auth: token });
        const [owner, repoName] = repo;
        // Configure git
        const { execSync } = require('child_process');
        execSync('git config user.name "RN A11y Audit Bot"');
        execSync('git config user.email "a11y-audit@users.noreply.github.com"');
        // Check if there are changes to commit
        try {
            execSync('git diff --quiet');
            console.log(chalk_1.default.gray("‚ÑπÔ∏è  No changes to commit"));
            return;
        }
        catch {
            // There are changes - continue with commit
        }
        // Stage and commit changes
        execSync('git add .');
        execSync('git commit -m "üîß Apply accessibility fixes from audit"');
        execSync('git push');
        console.log(chalk_1.default.green("‚úÖ Committed accessibility fixes to PR"));
    }
    catch (error) {
        console.error(chalk_1.default.red("‚ùå Failed to commit changes:"), error.message);
    }
}
if (!inputDir) {
    console.log(chalk_1.default.red("‚ùå Usage: rn-a11y-audit <path-to-src>"));
    process.exit(1);
}
const targetDir = process.argv[2];
if (!targetDir) {
    console.log(chalk_1.default.red("‚ùå Usage: rn-a11y-audit path/to/your/code"));
    console.log(chalk_1.default.gray("Example: rn-a11y-audit ./src"));
    process.exit(1);
}
(async () => {
    console.log(chalk_1.default.blue("üîç Running React Native accessibility audit..."));
    console.log(chalk_1.default.gray(`Scanning: ${targetDir}`));
    try {
        await walkDir(targetDir);
        // Always generate console report
        (0, generateReport_1.generateReport)(report);
        // Commit any fixes that were applied
        await commitFixesIfNeeded();
        // Transform comments and save JSON
        const commentsForPR = transformCommentsForPR(prComments);
        const reportsDir = path_1.default.join(process.cwd(), "reports");
        if (!fs_1.default.existsSync(reportsDir)) {
            fs_1.default.mkdirSync(reportsDir, { recursive: true });
        }
        const commentsPath = path_1.default.join(reportsDir, "comments.json");
        fs_1.default.writeFileSync(commentsPath, JSON.stringify(commentsForPR, null, 2));
        console.log(chalk_1.default.blue(`üìù PR comments written to ${commentsPath}`));
        console.log(chalk_1.default.gray(`Found ${commentsForPR.length} comments to post`));
        // Post to GitHub if in PR environment
        await postCommentsIfInPR(commentsForPR);
        console.log(chalk_1.default.green("‚úÖ Audit complete"));
    }
    catch (error) {
        console.error(chalk_1.default.red("‚ùå Audit failed:"), error instanceof Error ? error.message : error);
        process.exit(1);
    }
})();
//# sourceMappingURL=index.js.map